<#@ Include File="TemplateHeader.t4" #>
<#@ Modeling ElementType="Microsoft.VisualStudio.Uml.Classes.IPackage" Processor="ModelingProcessor" ApplyStereotypes="CSharp" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.AuxiliaryConstructs" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.Classes" #>
<#@ import namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility" #>
<#@ import namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml" #>
<#@ Include File="CSharpCommentHelpers.t4" #>
<#@ Include File="CSharpHelpers.t4" #>
<#@ Output Extension=".generated.cs" #>
#pragma warning disable 1591
<# 
    WriteAutoGeneratedWarningHeader();
    string packageNamespace = this.Element.Name;
	string className = GetDataAccessProperty(this.Element, "persistentPackage", "ContextClass");
	if (String.IsNullOrEmpty(className)) className="EntitiesModel";
	string metadataSourceName = className+FluentMetadataSourceToken;
#>
using System;
using System.Linq;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Data.Common;
using Telerik.OpenAccess;
using Telerik.OpenAccess.Metadata;
using Telerik.OpenAccess.Data.Common;
using Telerik.OpenAccess.Metadata.Fluent;
using Telerik.OpenAccess.Metadata.Fluent.Advanced;
using Telerik.OpenAccess.Metadata.Relational;
<#
if(!string.IsNullOrEmpty(packageNamespace)) {
#>
using <#= packageNamespace #>;

namespace <#= packageNamespace #> {
<#
    PushIndent("\t");
}
#>
public partial class <#= metadataSourceName #> : <#= FluentMetadataSourceToken #> {
<# PushIndent("\t"); #>
protected override IList<MappingConfiguration> PrepareMapping() {
<# PushIndent("\t"); #>
List<MappingConfiguration> mappingConfigurations = new List<MappingConfiguration>();
<#
				//WriteLine("// " + this.Element);
				IEnumerable<IClass> persistentTypes = this.Element.OwnedElements.OfType<IClass>();
				foreach(IClass persistentType in persistentTypes) {
					string methodNameToken = GetMappingConfigurationMethodName(persistentType);
					string typeToken = GetGenericMappingConfigurationTypeToken(persistentType);
					string variableToken = string.Concat(persistentType.Name.ToLower(), "Configuration");
					WriteLine(typeToken + " " + variableToken +" = this." + methodNameToken + "();");
					WriteLine("mappingConfigurations.Add(" + variableToken + ");");
				}
#>
return mappingConfigurations;
<# PopIndent(); #>
}
protected override void SetContainerSettings(MetadataContainer container) {
<# PushIndent("\t"); #>
container.Name = "EntitiesModel";
container.DefaultNamespace = "<#= packageNamespace #>";
container.NameGenerator.RemoveLeadingUnderscores = false;
container.NameGenerator.SourceStrategy = Telerik.OpenAccess.Metadata.NamingSourceStrategy.Property;
container.NameGenerator.RemoveCamelCase = false;
<# PopIndent(); #>
}
<#
		this.GenerateMappingConfigurations(persistentTypes);
		PopIndent();
#>
}
<#
    ClearIndent();
    if (!String.IsNullOrEmpty(packageNamespace)) {
#>
}
<#  } #>
#pragma warning restore 1591
<#+
	static readonly string FluentMetadataSourceToken = "FluentMetadataSource";
	static readonly string MappingConfigurationToken = "MappingConfiguration";
	static readonly string ClassConfigurationToken = "ClassConfiguration";
	static readonly string PropertyConfigurationsToken = "PropertyConfigurations";
	static readonly string AssociationConfigurationsToken = "AssociationConfigurations";
    /// <summary>
    /// Gets the type token for the fluent mapping configuration type.
    /// </summary>
    /// <param name="persistentType">type to be configured</param>
    /// <returns>type token</returns>
	private string GetGenericMappingConfigurationTypeToken(IClass persistentType) {
		string typeName = persistentType.Name;
		if(string.Equals(persistentType.Namespace, persistentType.Name)) {
			typeName = string.Concat(persistentType.Namespace, ".", persistentType.Name);
		}
		return string.Concat(MappingConfigurationToken,'<',typeName,'>');
	}
    /// <summary>
    /// Gets the mapping configuration method name for the persistent class.
    /// </summary>
    /// <param name="persistentType">type to be configured</param>
    /// <returns>method name</returns>
	private string GetMappingConfigurationMethodName(IClass persistentType) {
		return string.Concat("Get",persistentType.Name, MappingConfigurationToken);
	}
    /// <summary>
    /// Generate the mapping configurations for every persistent class.
    /// </summary>
    /// <param name="persistentTypes">list of types to be persisted</param>
	private string GetClassConfigurationMethodName(IClass persistentType) {
		return string.Concat("Get",persistentType.Name, ClassConfigurationToken);
	}
	private string GetPropertyConfigurationsMethodName(IClass persistentType) {
		return string.Concat("Prepare",persistentType.Name, PropertyConfigurationsToken);
	}
	private string GetAssociationConfigurationsMethodName(IClass persistentType) {
		return string.Concat("Prepare",persistentType.Name, AssociationConfigurationsToken);
	}
	private void GenerateMappingConfigurations(IEnumerable<IClass> persistentTypes) {
		foreach(IClass persistentType in persistentTypes) {
			GeneratePersistentClassConfiguration(persistentType);
			GenerateClassLevelMappingConfiguration(persistentType);
			GeneratePreparePropertyConfigurationsMethod(persistentType);
			GeneratePrepareAssociationsConfigurationsMethod(persistentType);
		}
	}
	private void GeneratePersistentClassConfiguration(IClass persistentType) {
		string methodNameToken = this.GetMappingConfigurationMethodName(persistentType);
		string typeToken = this.GetGenericMappingConfigurationTypeToken(persistentType);
	
		string classConfigurationMethodName = this.GetClassConfigurationMethodName(persistentType);
		string propertyConfigurationsMethodName = this.GetPropertyConfigurationsMethodName(persistentType);
		string associationsConfigurationsMethodName = this.GetAssociationConfigurationsMethodName(persistentType);
	
		IEnumerable<IProperty> primitiveMembers = persistentType.OwnedAttributes;
		IEnumerable<IProperty> navigationMembers = GetNavigableOwnedEnds(persistentType, primitiveMembers);
		bool hasPrimitiveMembers = primitiveMembers.Count() > 0;
		bool hasAssociations = navigationMembers.Count() > 0;
	
#>
public <#= typeToken #> <#= methodNameToken #>() {
<#+ PushIndent("\t"); #>
<#= typeToken #> configuration = this.<#= classConfigurationMethodName #>();
<#+ 
		if(hasPrimitiveMembers) {
#>
this.<#= propertyConfigurationsMethodName #>(configuration);
<#+ 
		}
		if(hasAssociations) {
#>
this.<#= associationsConfigurationsMethodName #>(configuration);
<#+ 
		}
		this.WriteLine(string.Empty);
#>
return configuration;
<#+ PopIndent(); #>
}
<#+
		this.WriteLine(string.Empty);
	}

	private void GenerateClassLevelMappingConfiguration(IClass persistentType) {
		string typeToken = this.GetGenericMappingConfigurationTypeToken(persistentType);
		string classConfigurationMethodName = this.GetClassConfigurationMethodName(persistentType);
		string inheritanceToken = this.GetInheritanceToken(persistentType);
		// prepared to be integrated, but not (fully) implemented yet
		string discriminatorColumnToken = String.Empty;
		// prepared to be integrated, but not (fully) implemented yet
		string discriminatorValueToken = String.Empty;
		string dataAccessKindToken = this.GetClassDataAccessKindToken(persistentType);
		// prepared to be integrated, but not (fully) implemented yet
		string concurencyControlToken = this.GetConcurrencyControlToken("");
		// prepared to be integrated, but not (fully) implemented yet
		string cacheStrategyToken = this.GetCacheStrategyToken("");
		string withCascadeDeleteToken = this.GetWithCascadeDeleteToken(persistentType);
		string tableToken = this.GetTableToken(persistentType);
#>
public <#= typeToken #> <#= classConfigurationMethodName #>() {
<#+ PushIndent("\t"); #>
<#= typeToken #> configuration = new <#= typeToken #>();
configuration.MapType(x => new { })<#= dataAccessKindToken #><#= concurencyControlToken #><#= cacheStrategyToken #><#= inheritanceToken #><#= discriminatorColumnToken #><#= discriminatorValueToken #><#= withCascadeDeleteToken #><#= tableToken #>;

return configuration;
<#+ PopIndent(); #>
}
<#+ 
	}

	private void GeneratePreparePropertyConfigurationsMethod(IClass persistentType) {
		string propertyConfigurationsMethodName = this.GetPropertyConfigurationsMethodName(persistentType);
		string typeToken = this.GetGenericMappingConfigurationTypeToken(persistentType);
		IEnumerable<IProperty> primitiveMembers = persistentType.OwnedAttributes;
		IEnumerable<IProperty> navigationMembers = GetNavigableOwnedEnds(persistentType, primitiveMembers);
		// add associations
		if((primitiveMembers == null || primitiveMembers.Count() == 0) && (navigationMembers == null || navigationMembers.Count() == 0) )
			return;
#>	
public void <#= propertyConfigurationsMethodName #>(<#= typeToken #> configuration) {
<#+
		PushIndent("\t");
		foreach(IProperty primitiveMember in primitiveMembers) {
			this.GeneratePropertyConfiguration(primitiveMember);
		}
		foreach(IProperty member in navigationMembers) {
			// Only for navigation properties with persistence options (e.g. being part of the identity)
			if (HasDataAccessStereotype(member)) this.GeneratePropertyConfiguration(member);
		}
		// write interface properties
		var list = ImplementedAndInheritedTypes(persistentType).Where(e => GetStereotype(e) == "interface");
		foreach (IInterface item in list) {
			foreach (IProperty property in item.OwnedAttributes)
				if(GetStereotype(property) == "property") this.GeneratePropertyConfiguration(property);
        }
		PopIndent();
#>
}
<#+
	}

	private void GeneratePrepareAssociationsConfigurationsMethod(IClass persistentType) {
		string methodNameToken = this.GetAssociationConfigurationsMethodName(persistentType);
		string typeToken = this.GetGenericMappingConfigurationTypeToken(persistentType);

		IEnumerable<IProperty> navigationMembers = GetNavigableOwnedEnds(persistentType, persistentType.OwnedAttributes);
		if(navigationMembers == null || navigationMembers.Count() == 0)
			return;
#>	
public void <#= methodNameToken #>(<#= typeToken #> configuration) {
<#+
		PushIndent("\t");
		foreach(var navigationMember in navigationMembers) {
			this.GenerateAssociationConfiguration(navigationMember);
		}
		PopIndent();
#>
}
		
<#+
	}

	private void GeneratePropertyConfiguration(IProperty primitiveMember) {
		string propertyName = primitiveMember.Name;
		if (string.IsNullOrEmpty(propertyName))
			return;
	
		string hasPropertyToken = this.GetHasPropertyToken(primitiveMember);
		string isIdentity = this.GetIsIdentityToken(primitiveMember);
		string hasFieldNameToken = this.GetHasFieldNameToken(primitiveMember);
		string isNullableToken = this.GetIsNullableToken(primitiveMember);
		string isVersionToken = this.GetIsVersionToken(false);
		string dataAccessKindToken = String.Empty; // this.GetDataAccessKindToken("ReadWrite");
		string hasColumnTypeToken = string.Empty;
		string hasPrecisionToken = this.GetHasPrecisionToken(primitiveMember);
		string hasScaleToken = this.GetHasScaleToken(primitiveMember);
		string toColumnToken = this.GetToColumnToken(primitiveMember);
		string converterToken = string.Empty;
		string hasDefaultValueToken = this.GetHasDefaultValueToken(primitiveMember);
	
#>
configuration<#= hasPropertyToken #><#= isIdentity #><#= hasFieldNameToken #><#= isVersionToken #><#= dataAccessKindToken #><#= toColumnToken #><#= isNullableToken #><#= hasColumnTypeToken #><#= hasPrecisionToken #><#= hasScaleToken #><#= converterToken #><#= hasDefaultValueToken #>;
<#+
	}

	private void GenerateAssociationConfiguration(IProperty navigationMember) {
		string propertyName = navigationMember.Name;
		if (string.IsNullOrEmpty(propertyName)) {
			return;
		}

		string hasAssociationToken = this.GetHasAssociationToken(propertyName);
		string hasFieldNameToken = String.Empty; //this.GetHasFieldNameToken(navigationMember);
		string loadingBehaviorToken = string.Empty;
		string withOppositeToken = this.GetWithOppositeToken(navigationMember);
		string isManagedToken = this.GetIsManagedToken(navigationMember);
		string isDependentToken = this.GetIsDependentToken(navigationMember);
		string dataAccessKindToken = String.Empty; // this.GetDataAccessKindToken("ReadWrite");
		string hasConstraintToken = this.GetHasConstraintToken(navigationMember);
		string toColumnToken = this.GetToColumnToken(!IsEnumerable(navigationMember) ? navigationMember : navigationMember.Opposite);
		string orderByToken = this.GetOrderByToken(string.Empty);
		string mapJoinTableToken = this.GetMapJoinTableToken(navigationMember);
		string isRequiredToken = this.GetIsRequiredToken(navigationMember);
	
#>
configuration<#= hasAssociationToken #><#= hasFieldNameToken #><#= loadingBehaviorToken #><#= withOppositeToken #><#= toColumnToken #><#= hasConstraintToken #><#= orderByToken #><#= isManagedToken #><#= isDependentToken #><#= isRequiredToken #><#= dataAccessKindToken #><#= mapJoinTableToken #>;
<#+
	}
	private string GetHasAssociationToken(string propertyName) {
		string hasAssociationToken = string.Format(@".HasAssociation(x => x.{0})", propertyName);
		return hasAssociationToken;
	}

	private string GetWithOppositeToken(IProperty navigationMember) {
		IAssociation association = navigationMember.Association;
		if(association == null)
			throw new ArgumentException("navigationMember");
	
		var oppositeMember = navigationMember.Opposite;

		string withOppositeToken = string.Empty;
		if(oppositeMember != null) {
			string oppositeMemberPropertyName = oppositeMember.Name;
			if(!string.IsNullOrEmpty(oppositeMemberPropertyName) && association.NavigableOwnedEnds.Where(e => e.Name == oppositeMember.Name).Count() == 1)
				withOppositeToken = string.Format(".WithOpposite(x => x.{0})",oppositeMemberPropertyName);
		}
	
		return withOppositeToken;
	}
	private string GetHasConstraintToken(IProperty navigationMember) {
		var association = navigationMember.Association;
		string token = string.Empty;
		if(association != null) {
			string value = GetDataAccessProperty(association, "persistentAssociation", "Constraint");
			if(!string.IsNullOrEmpty(value)) {
				bool isSecondRole = association.NavigableOwnedEnds.Last().Name == navigationMember.Name;
				if (isSecondRole && association.NavigableOwnedEnds.Count() == 2) { // swap the parameters if we are on the other side of the association
					int endbrace = value.IndexOf(')');
					string param = value.Substring(1, endbrace-1);
					int comma = param.IndexOf(',');
					string detail = comma==1 ? param[0].ToString() : param.Substring(0, comma-1);
					string master = param.Substring(comma+1, param.Length-comma-1).TrimStart(' ');
					value = "("+master+", "+detail+value.Substring(endbrace);
					//Write("/* constraint: {0}, master:{1}, detail: {2} */", value, master, detail);
                }
				token = string.Format(".HasConstraint({0})", value);
            }
		}
	
		return token;
	}

	private string GetHasFieldNameOppositeToken(IProperty navigationMember) {
		IAssociation association = navigationMember.Association;
		if(association == null)
			throw new ArgumentException("navigationMember");
	
		var oppositeMember = navigationMember.Opposite;

		string hasFieldNameOppositeToken = string.Empty;
		if(oppositeMember != null) {
			string oppositeMemberFieldName = oppositeMember.Name;
			if(!string.IsNullOrEmpty(oppositeMemberFieldName))
				hasFieldNameOppositeToken = this.GetHasFieldNameToken(navigationMember);
		}
	
		return hasFieldNameOppositeToken;
	}

	private string GetIsManagedToken(IProperty member) {
		string token = string.Empty;
		// read the associations property
		string value = GetDataAccessProperty(member.Owner, "persistentAssociation", "IsManaged");
		if(!string.IsNullOrEmpty(value))
			if(Convert.ToBoolean(value)) token = ".IsManaged()";

		return token;
	}
	private string GetIsDependentToken(IProperty member) {
		string token = string.Empty;
		IAssociation association = member.Association;
		// read the associations property
		string value = GetDataAccessProperty(association, "persistentAssociation", "IsDependent");
		if ((value == "1st" && association.OwnedEnds.First().Name == member.Name) ||
			(value == "2nd" && association.OwnedEnds.Last().Name == member.Name))
				token = ".IsDependent()";

		return token;
	}

	private string GetInheritanceToken(IClass persistentType) {
		string inheritanceStrategy = GetDataAccessProperty(persistentType, "persistentClass", "InheritanceStrategy");;
		string inheritanceToken = string.Empty;
	
		if(!string.IsNullOrEmpty(inheritanceStrategy))
			inheritanceToken = string.Format(@".Inheritance(InheritanceStrategy.{0})",inheritanceStrategy);
	
		return inheritanceToken;
	}

	private string GetTableToken(IClass persistentType) {
		string tableName = GetDataAccessProperty(persistentType, "persistentClass", "TableName");
		string tableToken = string.Empty;

		if(!String.IsNullOrEmpty(tableName))
			tableToken = string.Format(@".ToTable({0})",tableName);

		return tableToken;
	}

	private string GetHasPropertyToken(IProperty primitiveMember) {
		if(primitiveMember == null)
			return null;
	
		string propertyName = primitiveMember.Name;
		string castToken = string.Empty;
		IType primitiveType = primitiveMember.Type;

		//	Write("/* IsAssoc: {0} */", (primitiveMember.Association != null && HasDataAccessStereotype(primitiveMember)).ToString());
/*		if (primitiveMember.Association != null && HasDataAccessStereotype(primitiveMember)) {
			propertyName = GetDataAccessProperty(primitiveMember, "persistentProperty", "FieldName");
			IProperty identityProperty = GetIdProperty(primitiveMember);
			//System.Diagnostics.Debug.Assert(identityProperty == null, "no identity (HasPropertyToken):"+primitiveMember.Name);
			primitiveType = identityProperty.Type;
        }*/
		if (primitiveType != null) {
			string clrType = TypeName(primitiveType);
			if(clrType != null && (clrType == "ulong")) {
				castToken = "(long)";
			}
		}
	
		return string.Format(".HasProperty(x => {0}x.{1})",castToken, propertyName);
	}

	private string GetIsIdentityToken(IProperty member) {
		string retValue = String.Empty;
		if(member != null) {
			string value = GetDataAccessProperty(member, "persistentProperty", "IsIdentity");
			bool isIdentity = false;
			if(!string.IsNullOrEmpty(value)) isIdentity = Convert.ToBoolean(value);
			// an identity Property needs a key generator
			if (isIdentity) {
				string keyGenerator = GetDataAccessProperty(member, "persistentProperty", "KeyGenerator");
				if (keyGenerator == "Default") keyGenerator = String.Empty;
				if(!String.IsNullOrEmpty(keyGenerator)) keyGenerator = string.Format("{0}.{1}","KeyGenerator", keyGenerator);
				retValue = string.Format(".IsIdentity({0})",keyGenerator);
			}
		}
		return retValue;
	}

	private string GetHasFieldNameToken(IProperty member) {
		// associations use the db field as foreign key field, so ignore it here;
		if (member.Association == null || !HasDataAccessStereotype(member)) {
			string fieldName = GetDataAccessProperty(member, "persistentProperty", "FieldName");
			if (!(string.IsNullOrEmpty(fieldName) || fieldName.Contains("<")))
				return string.Format(@".HasFieldName(""{0}"")", fieldName);
        }
		return string.Empty;
	}

	private string GetHasDefaultValueToken(IProperty primitiveMember) {
		// primitiveMember.Default is used in the class constructor, this here refers to the database default
		string hasDefaultValueToken = GetDataAccessProperty(primitiveMember, "persistentProperty", "HasDefault");
		if (!string.IsNullOrEmpty(hasDefaultValueToken))
			 hasDefaultValueToken =  @".HasDefaultValue()";
		else hasDefaultValueToken = String.Empty;
		return hasDefaultValueToken;
	}

	private string GetIsNullableToken(IProperty member) {
		string token = String.Empty;
		string value = GetDataAccessProperty(member, "persistentProperty", "IsNullable");
		// if set it overrides the "?" logic
		if(!string.IsNullOrEmpty(value))
			if(Convert.ToBoolean(value)) token = ".IsNullable()";
			else token = ElementType(member.Type, IsEnumerable(member)).EndsWith("?") ? ".IsNullable()" : ".IsNotNullable()";

		return token;
	}

	private string GetIsVersionToken(bool isVersion) {
		if (isVersion)
			return ".IsVersion()";
		return string.Empty;
	}

	private string GetToColumnToken(IProperty member) {
		string token = String.Empty;
		string value = GetDataAccessProperty(member, "persistentProperty", "FieldName");
		if (!string.IsNullOrEmpty(value)) return string.Format(@".ToColumn(""{0}"")", value);
	
		return token;
	}

	private string GetHasScaleToken(IProperty member) {
		string token = String.Empty;
		// Write("/* precision: {0} */", GetDataAccessProperty(member, "persistentProperty", "Precision"));
		int precision = int.TryParse(GetDataAccessProperty(member, "persistentProperty", "Precision"), out precision) ? precision : 0;
		string scale = GetDataAccessProperty(member, "persistentProperty", "Scale");
		if (precision > 0 && !string.IsNullOrEmpty(scale)) token = string.Format(@".HasScale({0})", scale);
	
		return token;
	}

	private string GetHasPrecisionToken(IProperty member) {
		string token = String.Empty;
		// Write("/* precision: {0} */", GetDataAccessProperty(member, "persistentProperty", "Precision"));
		int precision = int.TryParse(GetDataAccessProperty(member, "persistentProperty", "Precision"), out precision) ? precision : 0;
		if (precision > 0)
			if(ElementType(member) == "string") token = string.Format(@".HasLength({0:#})", precision);
			else token = string.Format(@".HasPrecision({0:#})", precision);
	
		return token;
	}

	private string GetIsRequiredToken(IProperty member) {
		string token = string.Empty;
		string value = GetDataAccessProperty(member, "persistentProperty", "IsRequired");
		if(!string.IsNullOrEmpty(value))
			if(Convert.ToBoolean(value)) token = ".IsRequired()";
		return token;
	}

	private string GetOrderByToken(string orderBy) {
		if (!string.IsNullOrEmpty(orderBy)) return string.Format(@".OrderBy(""{0}"")", orderBy);
	
		return string.Empty;
	}

	private string GetClassDataAccessKindToken(IClass member) {
		string token = string.Empty;
		string value = GetDataAccessProperty(member, "persistentClass", "DataAccessKind");
		if(!string.IsNullOrEmpty(value))
			token = string.Format(@".WithDataAccessKind(DataAccessKind.{0})", value);
		return token;
	
	}

	private string GetConcurrencyControlToken(string optimisticConcurrencyControlStrategy) {
		string optimisticConcurrencyControlStrategyToken = String.IsNullOrEmpty(optimisticConcurrencyControlStrategy) ? string.Empty : "OptimisticConcurrencyControlStrategy."+optimisticConcurrencyControlStrategy;
		if (string.IsNullOrEmpty(optimisticConcurrencyControlStrategyToken))
			 return string.Empty;
	
		return string.Format(@".WithConcurencyControl({0})", optimisticConcurrencyControlStrategyToken);
	}

	private string GetCacheStrategyToken(string cacheStrategy) {
		string cacheStrategyToken = String.IsNullOrEmpty(cacheStrategy) ? string.Empty : "CacheStrategy."+cacheStrategy;
		if (string.IsNullOrEmpty(cacheStrategyToken))
			 return string.Empty;
	
		return string.Format(@".WithCacheStrategy({0})", cacheStrategyToken);
	}

	private string GetConverterToken(string converter) {
		if (string.IsNullOrEmpty(converter)) return string.Empty;
	
		return string.Format(@".WithConverter(""{0}"")", converter);
	}

	private string GetWithCascadeDeleteToken(IClass member) {
		string token = String.Empty;
		string cascadeDeleteOption = GetDataAccessProperty(member, "persistentClass", "UseCascadeDelete");
		if (!String.IsNullOrEmpty(cascadeDeleteOption)) token = String.Concat(".WithCascadeDelete(CascadeDeleteOption.", cascadeDeleteOption, ")");
		return token;
	}
	private string GetMapJoinTableToken(IProperty navigationMember) {
       	IAssociation joinTableAssociation = navigationMember.Association;
		string mapJoinTableToken = string.Empty;
       	if (joinTableAssociation != null) {
			// Write("/* last: {0} */", joinTableAssociation.NavigableOwnedEnds.Last().Name);
			// both n:m association and the target element? -> skip
			if (joinTableAssociation.NavigableOwnedEnds.Where(end => IsEnumerable(end)).Count() == 2 && joinTableAssociation.NavigableOwnedEnds.Last().Name != navigationMember.Name) {
				mapJoinTableToken = ".MapJoinTable()";
			}
       	}
		return mapJoinTableToken;
	}
    protected override bool AppliesToElement() {
		bool isBoundElement = this.Element.TemplateBindings != null && this.Element.TemplateBindings.Any();
//        return !isBoundElement && GetStereotype(this.Element) == "package";
		return true;
    }
#>